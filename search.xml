<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Poller线程</title>
    <url>/blog/2020/08/26/Poller%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>在启动NioEndpoint组件时，除了会启动Acceptor线程外，还会启动Poller线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Start poller thread</span></span><br><span class="line">poller = <span class="keyword">new</span> Poller();</span><br><span class="line">Thread pollerThread = <span class="keyword">new</span> Thread(poller, getName() + <span class="string">&quot;-ClientPoller&quot;</span>);</span><br><span class="line">pollerThread.setPriority(threadPriority);</span><br><span class="line">pollerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">pollerThread.start();</span><br></pre></td></tr></table></figure>

<p>Poller线程的任务：</p>
<ul>
<li>轮询PollerEvent队列，将队列里面interestOps为OP_REGISTER的元素对应的SocketChannel注册到Selector，监听的事件为SelectionKey.OP_READ。然后将这个PollerEvent重置并放入缓存，以便复用。</li>
<li>当Selector监听到通道“读就绪”时，用这条通道对应的包装类NioSocketWrapper来构建一个SocketProcessor实例，然后将这个实例提交给线程池Executor处理。</li>
<li>循环执行上面两个任务。</li>
</ul>
]]></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat中的一些优化手段</title>
    <url>/blog/2020/08/27/Tomcat%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/</url>
    <content><![CDATA[<h2 id="对于需要频繁创建和销毁的对象的优化"><a href="#对于需要频繁创建和销毁的对象的优化" class="headerlink" title="对于需要频繁创建和销毁的对象的优化"></a>对于需要频繁创建和销毁的对象的优化</h2><p>在需要频繁创建和销毁对象的场景中，我们可以将用过的对象缓存起来，在下一次需要的时候就从缓存中取，然后替换或者重置这个对象中的某些对应属性，就可以重复使用这个对象了，避免了每次创建和销毁对象的开销，有点类似于线程池，使用完了就放回池中，下次需要的时候就从池中拿。</p>
<a id="more"></a>

<p>Tomcat在很多地方都用到了这种优化方式，以NioChannel为例，NioChannel是对SocketChannel的封装，即一个连接就会对应一个NioChannel对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用一个栈来缓存NioChannel对象</span></span><br><span class="line"><span class="keyword">private</span> SynchronizedStack&lt;NioChannel&gt; nioChannels;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当连接到来时，先从缓存中取</span></span><br><span class="line"><span class="keyword">if</span> (nioChannels != <span class="keyword">null</span>) &#123;</span><br><span class="line">    channel = nioChannels.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 缓存中没有的话，就创建新对象</span></span><br><span class="line">    <span class="comment">// SocketBufferHandler是NioChannel中的一个组件</span></span><br><span class="line">    SocketBufferHandler bufhandler = <span class="keyword">new</span> SocketBufferHandler(socketProperties.getAppReadBufSize(), socketProperties.getAppWriteBufSize(), socketProperties.getDirectBuffer());</span><br><span class="line">    <span class="keyword">if</span> (isSSLEnabled()) &#123;</span><br><span class="line">        channel = <span class="keyword">new</span> SecureNioChannel(bufhandler, selectorPool, <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        channel = <span class="keyword">new</span> NioChannel(bufhandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NioSocketWrapper是NioChannel的包装类</span></span><br><span class="line">NioSocketWrapper newWrapper = <span class="keyword">new</span> NioSocketWrapper(channel, <span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 重置NioChannel对象，即把NioChannel对象的属性与当前连接对应，同时也会重置它内部的SocketBufferHandler组件</span></span><br><span class="line">channel.reset(socket, newWrapper);</span><br></pre></td></tr></table></figure>

<p>当关闭连接时，会把这个NioChannel重新入栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nioChannels.push(getSocket())</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
</search>
